# 第二课、面向对象
古老的程序员，开发时是`面向过程`的一种思维方式。简单理解就是，每一个程序都以`1.2.3.4.5`写法，逐行逐字写出来，这样就难免要手动去实现一些逻辑。尽管可以复制粘贴代码，但哪里有`面向对象`来得实在？`面向对象`的程序员，所有的逻辑都是现成的，拿来就可以用。比复制粘贴大法，要先进一百倍。但是，你不能单纯地把`面向对象`理解为`拿来主义`。很多时候，你其实是在给自己`造轮子`，所以在`拿来`的过程中，你要明白，对方为什么要这样设计，是不是有某种奥义在里面。当你理解了这种设计方式，你就会逐渐领悟到`面向对象`的真实面目。这个时候你才会觉得，并不是`拿来就用`这么简单。你要对每个部分负责，你要考虑到最简单的使用，最严格的封装，最灵活的扩展，以及最良好的性能。当然，在Java里面谈性能，就好似在窑子里谈快感一样，并不好笑。但你必须遵守这个最高守则。

## 2.1 面向对象程序设计概述
面向对象就是在分解问题，分门别类，把数据集中在一块，把算法放在另一块，当遇到错误的时候，定位起来非常方便。在开发过程中，你也会享受到难以言喻的快乐。

### 2.1.1 类
`属性`和`方法`的集合体，`对象`的模板，当设计好了模板之后，创建`对象`就变得十分简单。

- **封装：**通过对细节的封闭，对使用的开放，Java程序设计只要做好权限控制，就做到了良好的封装。
- **扩展：**扩展即为继承，是把需要的部分拿来，是不需要的部分重新设计。——通常情况下，不建议滥用继承。

### 2.1.2 对象
`对象`就像砖窑里烧制出来的砖头，每一个都相差无几，但每一个都是真实的存在。Java程序中的对象稍微有点厉害，它在需要的时候，使用`new`语句就可以构造出来，在不需要的时候，有一个垃圾回收机制会自动回收它。所以对象比砖头厉害一些。

### 2.1.3 识别类
设计一个类其实很简单，没有所谓的无从下手。如果你总是在想如何下手，为什么就不随便选一个方向，开始自己的旅程呢？荷包蛋是圆的，你就不知道从哪边开始啃了吗？比如网购下订单，首先你是去买`商品`——`Item`，然后你选好了会有一个生成`订单`——`Order`，为了收到商品，你要告诉卖家你的`送货地址`——`Shipping address`，写完了地址之后，商家需要你在线`付款`——`Payment`，而付款的时候，你得建立一个`账户`——`Account`，等等。从这些名词出发，建立相应的`class`类，类里面当然包含对应的属性，然后针对这些属性，去联系相关的动词，就完成了一个订单系统的设计。

### 2.1.4 类之间的关系
像人与人之间存在某些或暧昧或惨淡的关系，类与类之间也有类似的情况。

- **依赖：**打个比方说，订单需要知道是谁下的单，所以需要有账户来建立只属于某个用户的订单，这个时候，订单会拿到账户对象，来进行资料访问。此时就说，订单要使用账户才能建立订单的实例，订单的生成依赖具体的账户对象。
- **聚合：**聚合可以认为是一堆数据，通过数组或集合的形式，聚集在一起。但是，最好不要产生这样简陋的认知，而应该明白，订单不依赖于具体的商品，所以可以把商品全部清空，也不会导致订单的销毁。不过大部分情况下，订单的建立，还是因为至少有一个商品的存在。
- **继承：**继承的概念不用多解释，懂的自然懂。

其他像`接口实现`、`关联`、`直接关联`等，可以记住UML连接符，这些符号基本上说明了关系的演变。而大部分情况下，是程序员在`设计开发`的过程中，慢慢总结出来的经验。

### 本节总结
遵循前人总结的经验教训，就能够很好地把握程序的脉搏，做出优秀完美无bug的程序。


## 2.2 预定义类
预定义实际上指的是，Java语言设计者，将各种常用的典型的类设计出来，提供给其他开发者使用。当然你也可以认为他们写出来的是垃圾，你更愿意实现出自己的类。不过，作为初学者，总要有一个适合学习的类，来当作样例。等掌握了有关知识的大部分细节后，再来谈自定义吧。

### 2.2.1 对象与对象变量
对象不是写在代码里面的固定内容，对象是按照一系列的定义（就是类），在内存中鲜活生存的数据。构造对象，初始化，通过内存地址操作对象。这是程序员常干的事情，在C语言中，操作内存简直是一种痛苦，Java避免了让人痛苦的操作，直接以对象的形式，逐一对应内存中的数据，就把有关`指针`的概念剥离出去，让程序员只关心数据，不用再理会数据在内存中的状态了。

所谓通过内存地址操作对象，在操作之前，需要对地址值做一个引用，也就用到了对象变量。通过对象变量来引用（持有）一个对象的地址值，从而在需要使用的地方，通过`.`符号来操作对象。这比使用`指针`方便很多，对于指针而言，要声明指针，并将对象的地址值拿出来，交给指针保存。使用指针访问对象时，又要通过指针地址值，链接到对象地址值，然后取得对象。如果是数组指针的话，需要做一系列事情，来使用指针访问数组里面的对象/数据。简直是折磨。

为了方便初学者认识一个类是如何诞生的，这里采用`java.util.Date`来做说明。由于这个类没有设计好，如果存在一系列的问题，将有可能得不到良好的示范，但这个类又确实能全面体现出，类在设计时的各种问题。所以，假若遇到复杂或烦琐的概念，这里会跳过它们，将它们视为`存在即合理`。

#### java.util.Date类
首先，让我们从类的介绍开始：
> The class <code>Date</code> represents a specific instant in time, with millisecond precision.

**翻译为：**这个Date类表示一个特定的时间点，精确到毫秒。

毫秒来自`System.currentTimeMillis()`这个方法，它的返回值以毫秒为单位。由于目前是用整型描述毫秒值的时间，这样的数字级别实在太长，如果不用`long`类型，那么`int`类型会一直溢出（超出最大值），至于`long`类型在未来某天也会溢出，这种担心就没有必要了，未来`Java`还不一定存在呢。

回头简单说说`System.currentTimeMillis()`方法，它返回的值代表 **自1970年1月1日午夜时分至现在**，本初子午线（UTC时区）经历的总毫秒值。另外有关计算机纪元这种概念，暂且放过它。当有了0时区的起始时间和流逝时间（起始到现在的间隔值），接下来只要知道运行代码的系统所在时区，就能换算出`本地时间`的当前时间点是多少。

那么设计为时间点（时刻）的Date类，就应该采用这个毫秒值作为基础属性。

```
private transient long fastTime;
```

先不管`transient`关键字是什么含义，从上面的代码可以看到，命名为`fastTime`的`long`类型变量，是私有的`private`访问权限。那么接下来应该怎么设计Date类呢？

当然是针对`fastTime`进行构造方法的初始化了，一个类首先要设计好构造方法，其次才是需要让开发者调用的方法，最后才是一些内部逻辑。

```
public Date() {
    this(System.currentTimeMillis());
}
```

果然，默认的构造方法，调用了自身的另外一个有参构造方法，将系统时间点作为参数传递过去。

```
public Date(long date) {
    fastTime = date;
}
```

毫无疑问的，参数被赋值给了`fastTime`，我们可以猜一猜类设计者的最初想法，应该是觉得原子时钟经历的时间长度，足够说明一切时间点了。

再看看是否还有其他构造方法，如果有，看看能否探索一下。

```
@Deprecated
public Date(int year, int month, int date) {
    this(year, month, date, 0, 0, 0);
}
```

确实还有多个其他参数的构造方法，应该是不同的意义，但最终的目的还是用来初始化属性，当然，不一定是`fastTime`这个属性。上面代码中的`@Deprecated`表示一个注解，就相当于古人阅读书籍的时候，喜欢在一段句子旁边，做一些个人理解上的批注一样。这个注解放在这里表示，这个构造方法已经过时，将被弃用（删除），不推荐Java开发者继续使用它，应该参照说明调用其他形式的构造方法。

从参数名字来推断，第一个应该是年，第二个是月，第三个是日。那么可以毫不犹豫地认定，设计者最初想用`int`类型表示的公历年月日，来解析出`fastTime`毫秒值。回过头来想想，Date类的简短介绍是什么？一个特定的时间点！怎么可能使用年月日来建立呢？这是设计的失误之处，时间点应该就是纯粹的时间点，不能用日历的形式来初始化。即便要用日历的形式，也应该创建一个新的日历类`Calendar`，然后接收时间点来作为年月日初始化的依据（依赖）。

```
@Deprecated
public Date(int year, int month, int date, int hrs, int min, int sec) {
    int y = year + 1900;
    // month is 0-based. So we have to normalize month to support Long.MAX_VALUE.
    if (month >= 12) {
        y += month / 12;
        month %= 12;
    } else if (month < 0) {
        y += CalendarUtils.floorDivide(month, 12);
        month = CalendarUtils.mod(month, 12);
    }
    BaseCalendar cal = getCalendarSystem(y);
    cdate = (BaseCalendar.Date) cal.newCalendarDate(TimeZone.getDefaultRef());
    cdate.setNormalizedDate(y, month + 1, date).setTimeOfDay(hrs, min, sec, 0);
    getTimeImpl();
    cdate = null;
}
```

上面的代码说实话，实在太复杂了。复杂到根本看不懂，不知道在做什么。如果一个构造方法，像发了疯一样。这个构造方法就已经废了。

那么，我们继续看其他的构造方法，对于复杂的地方，没有必要花费精力去研究，浪费时间不说，又辣眼睛又难受，跳过跳过。

```
@Deprecated
public Date(String s) {
    this(parse(s));
}
```

这个构造方法也废弃了，但值得高兴的是，它的逻辑特别简单，甚至用字符串来初始化。那么，我们去看看它调用的`parse()`方法吧。

```
@Deprecated
public static long parse(String s) {
    // 此处省略160行代码
    // syntax error
    throw new IllegalArgumentException();
}
```

等等，让我先骂几句脏话！一个方法的逻辑竟然超过160行代码？这样的设计真的烂，就算是JDK里面的预定义类，也必须骂。

`Date`类的设计果然是这样的糟糕，甚至打消了初学者对类的学习积极性。但有一个地方值得庆幸，那就是我们在使用JDK API的时候，没有遇到什么致命错误。所以JDK API还是适合初学者学习的，只是Date这种垃圾样例类，是不能再作为学习目标了。

### 2.2.2 LocalDate类
别！别别！再来一个这样的类恶心人吗？好吧，强忍着恶心看下去，其实事情还是有转机的，至少核心技术里面，把覆盖的所有知识点都讲明白了。尽管可能初学者一时之间无法全部领悟，但这样的神书，自然有理由放在身边`年年月月越是觉得深爱它`呀！

**请耐心把这节内容看完，很重要！**

至于为什么不讲解？因为无法将这节内容讲得更通俗，它已经是非常棒的解说了！

另外，看`LocalDate`的源码，果然有一股赏心悦目的感受。并且从最上层版权注释可以看到，原先这个类是别的组织开源的，后来在Java1.8版本中，被引入作为JavaAPI。

### 其他小节
由于这部分内容实在过于精细，书上讲解得已非常精彩，所以不敢再过度解读。

### 本节总结
从这节开始，核心技术逐渐展现了它真正的魅力，对象、类、属性、方法、构造、参数、等等等等。
