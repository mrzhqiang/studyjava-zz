# 第一课、程序结构
通过对程序结构的分析，来深入了解Java源代码，以及开发Java程序是怎么一回事。

## 1.1 最简单的应用程序——Hello,World
学一门语言，特别是计算机语言，首先要学会打招呼。让我们从最简单的， 也是最经典的地方开始。

**HelloWorld.java**
```
package com.github.mrzhqiang;

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello,World!");
    }
}
```

### 1.1.1 分析——个人理解
- `package`：包，分门别类，用来划分不同功能的代码区域，通常以域名相反的顺序来命名。
- `public`：关键字，权限访问修饰符，用来表明类、变量、方法是否可被访问，`public`表示具有完全访问权限。
- `class`：类，变量和方法的集中营，用来组织数据结构和算法，将程序员从细节处抽离，建立程序开发的大局观。
- `static`：静态，表示一个类、变量、方法是否为静态形式，通常用来声明类是独立的，变量和方法是共享的。
- `void`：空，是一种特殊类型，表示什么也没有，因此不需要方法返回任何内容。
- `String[]`：字符串数组，`String`是字符串类，表示多个字符的组合；类的后面跟上一对中括号，表示当前类型的数组对象。
- `System.out.println`：输出内容到控制台的静态方法，在开发中，常用来输出调试日志。
- `"`、`"`：一对引号，在前后引号的区域中，是一串字符，因此引号包括的一串字符，称为字符串，是多个字符的组合，是`String`对象。
- `{`、`}`：一对花括号，在前后花括号的区域中，`{`表示开始，`}`表示结束，组合起来表示代码块，在代码块中声明的变量，结束时会被回收。

### 1.1.2 笔记——划重点
1. **区分大小写：**
在Java中，大小写不同的单词，有着完全不同的意义。比如方法名，大小写不一样则是不同的方法；变量名和类名也是如此。
2. **访问修饰符：**控制访问级别意味着对使用者而言，需要知晓并可以使用的类和方法有哪些，合理规划访问级别可以做到最完美的黑匣子封装。
3. **类：**Java程序中的所有内容都包含在类中，我们把类当作加载程序逻辑的容器，程序逻辑定义应用程序的行为。
4. **类名的规则：**相比较而言，Java的命名规则比较宽松。首先类的名字以大写字母开头，相对特殊的类，比如抽象类，以Abstract或Base开头；其后可以跟字母和数字的任意组合，无长度限制，但基于阅读体验，最好控制一下长度；另外不允许使用Java保留字作为类名，通常这一点在IDEA中，很容易被警告。最后推荐一个比较好的IDEA插件，来规避这些问题：`Alibaba Java Coding Guidelines`——阿里巴巴Java开发规约插件。
5. **标准的命名规范：**大写开头，假若其后有多个单词组合，每个单词都必须以大写开头，这被称之为骆驼命名法。
6. **源代码文件名：**在Java中，文件名字跟公共类名字一样，使用`.java`作为扩展名，这在使用记事本开发时，需要格外注意；但如果是`IntelliJ IDEA`这种IDE可以避免这个问题。
7. **源代码编译：**源码经过编译后，就得到`.class`格式的字节码文件，字节码文件名与公共类名一致。如果使用DOS命令行编译，则会自动在源码目录下生成字节码文件；如果使用IDE的话，会根据一定规则，在`build`、`out`、`target`、`class`等编译目录下，生成具有包结构的字节码文件。
8. **运行：**得到字节码后，就可以在Java虚拟机中运行。命令行中，使用`java 类名`即可运行，需要注意的是，不加文件格式后缀；与之区分的是，`javac 类名.java`是用来编译源码为字节码文件。IDEA中，通过`main`方法前面的三角形图标运行即可。
9. **程序入口：**运行已编译的程序时，Java虚拟机从`main`方法开始执行，这被称之为程序的入口。
10. **代码块：**所有的类，以及类中的方法，都使用`｛`和`｝`划分区域，这将严格界定变量的使用范围，而程序，归根结底是通过算法将数据以一定的逻辑进行运算的便捷工具。
11. **语句结束标志：**类似于一句话的末尾要有`。`号，在Java中使用英文字符的`;`号作为语句的结束标志，因此，如果语句很长，完全可以分段落输入，只要最后记得使用结束标志。
12. **调用符号：**方法的调用是使用类或对象通过`.`符号来调用的，其中类调用的是静态方法——静态属于类；对象调用的是成员方法——成员属于对象，因此成员变量也可以用`.`来调用，只要拥有相应的访问权限。

### 本节总结
Java程序世界是精彩的，它比认识一个人要简单得多。尽管在这节课中，会产生各种各样的疑惑，但目前你需要暂时丢开它们，当作初次见面的陌生来看待。为了下次遇见它不至于陌生，你必须仔细记住它现在的模样，并且保持这种仔细。


## 1.2 注释——对容易混淆的代码进行解释，提供参考文档
注释是一种良好的习惯，对于开发者而言，是为了防止日后的遗忘；对于使用者或后继者而言，是提供快速入手的资料。写注释并不是一种时间浪费，而是通过对代码的注释，来反省一下是否有更好的选择，尽管在初级阶段，你并不能意识到这一点。但总的来说，会写注释的程序员，才算是合格的艺术家。

**Simple.java**
```
package com.github.mrzhqiang.c1;

/**
 * 这个<code>Simple</code>类只是一个简单的小程序。
 * <p>
 * 类和方法的注释，通常会使用JavaDoc输出Html文件，作为API文档。
 * <p>
 * 可以通过 Ctrl + Q 快捷键来预览效果。
 * <p>
 * 开头尽量简单，是概括性语句；第二行介绍一些特性、原理；后面可以补充使用方法和注意事项，等等。
 *
 * @author mrzhqiang
 */
public class Simple {

  /** 程序名字，代表了应用程序的实例名 */
  private String name;

  /** 默认的构造器 */
  public Simple() {
  }

  /**
   * 作为程序入口的主方法。
   * <p>
   * 接受一个字符串数组为参数，通常情况下没有使用这个参数。
   * <p>
   * main是公开的静态方法，不需要开发者来调用，Run的时候会自动进入这里。
   *
   * @param args 字符串数组参数，在DOS命令行中，是{@code java Simple 1 2 3}的形式，
   * 其中args是{@code String[]}类型，被输入参数{@code 1 2 3}逐个填充，因此使用{@code args[0]}
   * 可以访问{@code 1}，以及使用{@code args[2]}访问{@code 3}，再之后就没有参数，访问会出现异常。
   */
  public static void main(String[] args) {
    // TODO 2018/01/14

    // 一行语句要使用两个斜杠来注释，并且不能出现在语句之后
    // 如果要换行，那么就再用行注释放在最前面
    System.out.println("A simple Java program");

    /*
    要注释多行代码，请使用现在这种形式。
    但通常是为了将一大段无效代码注释。
    */

    // 比如：
    /*int length = 100;
    for (int i = 0; i < length; i++) {
      System.out.println("序号：" + i);
    }*/

    // 但是如果代码中已经包含/**/注释，那么就不能手动加上多行注释
    // 而是应该使用IDE快捷键：Ctrl + Shift + /
    // 快捷键会处理好这个问题

    // 还有另外一种方式，是为了将以前传入的参数替换
    String format = "%s%d%f";
    // %f = 0.1F
    System.out.println(String.format(format, "下标：", 1, 0.2F));
    /*
     * 不过，大部分情况下，不会使用这样的注释语句，只有一些代码不想直接删除，又不能出现在程序中时
     * 才需要用快捷键直接注释掉。然后提供给未来优化时一些参考，或者下次想测试这个地方还能不能使用
     * 就把它给恢复出来，也就是反注释处理——选中，按下快捷键，即可
     *  */
  }

  /**
   * 显示某些名字
   *
   * @param name 打印的名字
   */
  public void showSomething(String name) {
    System.out.println("Something:" + name);
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}
```

### 本节总结
注释的基本示范就在上面的代码里面，大部分情况下，用的还是`//`注释语句，简单明确地提示此处代码意义即可。只有当你想要开源一个框架，或者在某公司下，开发一个SDK给其他开发者使用，那么就需要用到`/** */`注释语句。最后一个注释语句`/* */`，是程序员用来开关代码逻辑，处理移植代码时不能通过编译的问题，也是相对常用的手段。


## 1.3 数据类型
计算机中的数据，最终形态是0和1，也就是二进制数。在Java中，1个字节`byte`表示`-128--127`的取值范围，这是十进制的形态，数字`127`转换为二进制是这样的：`0b0111_1111`，空余出来的首位将作为符号位，那么你可能猜测`0b1000_0000`表示`-1`，然后从这个数开始累加，直到`0b1111_1111`正好是`-128`。事实上并非如此，有关Java中的负数这个概念，请参考[Java byte 字节负数](http://blog.csdn.net/zdy10326621/article/details/50236529)这篇文章，讲解得比较详细，生动，有趣。假设你的猜测是正确的，那么`-1`加上`1`等于多少？会变成`-2`的话，就说明出现了世界观的颠覆。

### 1.3.1 笔记——划重点
- **整型：**没有小数部分的数值，允许负数的存在。`int`、`short`、`long`、`byte`是四种整型，各有用途：`int`最常用，`long`通常来表示时间的毫秒值，`short`和`byte`是处理底层逻辑时使用。
- **浮点型：**拥有小数部分，因为小数点可以浮动，因此形象地称之为浮点型。`float`和`double`基本都在使用，默认是`double`类型。由于浮点数存在无穷大`POSITIVE_INFINITY`和无穷小`NEGATIVE_INFINITY`以及非数字`NaN`这三个特殊值，因此对于这些情况，最好是调用相关包装类`Float`和`Double`的静态方法`compare`，通过传参的方式来进行比较。
- **char 类型：**表示单个字符，以及Unicode字符，通常用于底层处理，面向开发者的一般是`String`这个字符串类。

### 本节总结
基本数据类型就像组合单词的26个字母一样，它们在程序中扮演着一砖一瓦的角色，是最不可替代的部分，也是最基础的知识。必须熟悉它们，像熟悉26个字母一样。


## 1.4 变量
变量是指，在程序运行过程中，允许发生改变的某种类型的值，通常使用一个自定义名字来声明变量，然后可以用`=`赋值语句对它进行赋值。

### 1.4.1 声明和初始化
想要使用某种类型的变量，就需要对变量进行声明，例如：`int a;`是一个声明语句，前面是变量的类型，后面是变量的名字`a`，最后使用`;`符号结束。当完成一个类型的变量声明之后，紧接着就应该对变量进行初始化，否则的话，在类中，将由无参构造方法进行默认初始化——有关默认初始化的概念将在 **类和对象** 中介绍；在方法中，将视为无效的变量，IDEA会报错，表示必须进行局部变量的定义，也就是声明和初始化。

### 1.4.2 常量
常量是使用`final`标识的特殊变量，一旦定义就不能再次赋值。如果要声明一个类常量，还需要加上`static`关键字，以保证这个常量为类所有。通常意义上的常量，是在一些特殊情况下使用，比如匿名类的逻辑回调，会使用方法内定义的常量；而类常量是用来将某种类型值置顶全局使用，比如圆周率，它已经在`Math`类中定义，所有需要圆周率的地方，使用`Math.PI`这个值就行。

### 本节总结
变量用来暂时存储数据，尽管会有类变量与基本数据变量的区别，但类是属于基本数据变量的集合体，因此最终还是在处理最基本的数据。那么实际上变量是也一个非常重要的概念，在使用频率上，不会比基本数据类型少。


## 1.5  运算符
Java中的运算符与数学中的含义几乎没有差别，需要注意的是，程序运算会有一定的数值转换，比如两个整数，在进行`/`运算（除法）时，表示整数除法；其他情况，则属于浮点数除法，得到的结果值，将会是一个浮点数。另外，一些数学意义上的运算，在Java中需要调用辅助方法来完成，比如计算一个数值的平方根，需要用`Math.sqrt(x)`方法，将数值作为参数传递进去。`Math`这个类包括有大部分简单的数学运算。

- **结合赋值和运算符：**这是一种二元运算符，属于简写方式。例如：`x+=4` >>> `x=x+4`。
- **自增和自减运算符：**由于加1与减1这种操作太常见，为了方便起见，创造这样的一个运算符，表示变量自身的增减。
- **关系和boolean运算符：**由于程序是基本数据和算法逻辑的组合，因此会存在大量的关系运算，要检测相等性，可以使用`==`符号表示左右两个变量是否相等；使用`!=`表示左边的变量是否不等于右边的变量。另外还有`<`、`>`，`<=`、`>=`这些运算符。使用关系运算符得到的结果是`boolean`类型，而`boolean`可以使用`&`、`|`、`!`进行逻辑运算，它们分别是：逻辑与、逻辑或、逻辑非。逻辑与代表着，必须左右两边的结果都是`boolean`的`true`值，那么最终的结果才会是`true`，否则都将作为`false`处理；逻辑或代表着，只要有一边的结果为`true`，那么最终结果就是`true`；逻辑非代表着，将结果反转一下，`true`变为`false`，`false`变为`true`。如果逻辑与和逻辑或的符号是双份，比如`&&`，表示短路与，则需要左边的条件达成`true`，才会计算右边的条件；而短路或`||`则是左边的条件达成`false`，才去计算右边的条件。
- **位运算符：**这部分内容相当的底层，只需要知道`&`在处理二进制数时，是属于位运算的`按位与`，它是将第一个二进制数，比如`0b0101_0011`，与第二个二进制数，比如`0b0000_1111`，进行`按位与`运算，在第二个数中，遇到`0000`的情况，则清零与第一个数对应的数字，而遇到`1111`的情况，则将保留与第一个数对应的数字，原封不动。这样最后的结果是`0b0000_0011`，属于`擦黑板`行为。位运算符中的`|`是`按位或`，它表示`填充`行为，也就是遇到`1111`全部变成`1111`，遇到`0000`则不发生任何改变。位运算符中的`^`是`按位异或`，它表示的结果，与`按位或`有些不同，比如第二个数中的`1111`部分，与第一个数中对应的部分进行运算之后，`0011`会变成`1100`，也就是`0`会换为`1`，`1`会变为`0`。`按位异或`中的`0000`还是跟`按位或`一样，运算之后第一个数的值依旧原封不动。
- **括号与运算符级别：**括号是用来提升优先级的，运算符跟排队一样，有不同的级别自然会有不同的优先权，而最内层的括号总是最优先计算，然后是一些相应的运算符级别，再是外层的括号和运算符，层层递进之后，最终得到一个合理的结果。通常情况下不应该建立特别复杂的运算符组合，防止在维护时，浪费大量的时间理解当初的算法规则。
- **枚举类型：**限制变量的取值范围，是相对于常量更好的措施，因为常量通常情况下，会产生一个超出取值范围的值，导致算法出现不可预期的错误。

### 本节总结
运算符也是基本的概念之一，在入门精通中，提及的概念范围稍显狭窄，核心技术做到了全面覆盖，尽管可能存在啰嗦嫌疑，但实际上应该慎重对待，因为它也不比基本数据类型在使用频率上要少。

## 1.6 字符串
在某种概念上来看，字符串的字面含义，就属于字符的一串组合，那么对于字符串的一些简单处理方法，要学会。

### 1.6.1 子串、拼接、不可变
- **子串：**字符串既然是以串的形式存在，那么必定可以提取它的片段，也就是`子串`。
- **拼接：**既然可以提取片段，那么通过对片段的组合，也可以变成更大的字符串，也就是`拼接`。
- **不可变：**我们可以假设字符串是切糕，一刀下去，片段提取出来，原先的字符串就不完整了。这样对于程序开发来讲，是很严重的问题，因为你不知道什么时候，字符串会被一刀切碎。那么怎么样可以避免这种问题呢？将字符串类声明为不可变的类，这个时候任何字符串对象，都将是唯一的存在，即便你使用`子串`和`拼接`大法，也只是通过`拷贝`得到一个全新的字符串对象，不能再对原先的对象，进行任何形式上的修改。

### 1.6.2 检测相等、空串、Null串
- **equals：**`Object`是所有类的祖先（父类），它定义了`equals`方法用来比较两个对象是否相等。`String`字符串类，重写了比较方法，会针对每个字符进行字典意义上的比较。所以要检测字符串是否相等，基于字符串不可变性质，不应该使用`==`符号来比较，而是通过`String.equals()`方法来检测。有趣的是，通常情况下，常量可以使用`==`来比较值，这是因为常量放在同一个位置上，不会发生改变；而`+`号拼接出来的字符串对象，以及`substring`方法提取出来的`子串`，并没有放在相同的位置，因此，在这种情况下，使用`==`符号来比较是否处于相同的位置时，无法得到想要的结果。
- **""：**表示长度为0的字符串，它是空空如也，但不代表它不存在。
- **null：**表示对象不存在。

### 1.6.3 StringAPI
String类提供的方法很多很多，常用的无非是`substring`、`equals`、`length`、`replace`、`indexOf`、`startsWith`这些，以及它们相应的变种或重载。对于某个类的API，最好还是手头有一本电子文档，查询起来方便，也不需要花费大量的时间记忆，临阵磨枪是程序开发中常有的事。

### 本节总结
字符串属于应用程序开发不可或缺的一部分，通常情况下，网络、数据库，以及一些日志输出，都使用字符串来传输和显示结果。对于字符串，一定要熟悉并掌控关键方法。


## 1.7 输入输出
大部分情况下，程序是用来与人交互的，因此对于程序运行的情况，开发者首先就要了如指掌。如果不能显示程序运行的情况，那么对于开发者而言，是一件痛苦的事情。为了解决这个问题，Java提供了控制台输入输出方法，当然，这是建立在输入输出流的基础上，从目前的知识点来看，暂时只需要知道控制台输入输出是为了显示程序运行情况就行。

### 1.7.1 读取输入——扫描器
打印数据到屏幕的控制台上，是一件再简单不过的事情，在IDEA中，使用`sout`的快捷语法，就能够建立一条输出语句`System.out.println()`。而对于接收键盘输入，就稍微显得复杂了些。首先要得到一个扫描器，用来监听键盘是否有输入（按下键位）。`Scanner`就是一个扫描器，关联到标准输入流，即`System.in`，就可以读取键盘输入的任何信息。下面是一个简单的例子，通过标准输入流构造扫描器，使用扫描器对象守候键盘输入一行字符，所谓一行字符就是遇到回车键`\n`就完成了输入。
```
Scanner in = new Scanner(System.in);
System.out.println("Please input something: ");
String line = in.nextLine();
```
需要注意的是，`Scanner`并不是Java基础包`java.lang`里面的类，因此需要对它进行导入操作，才可以使用它。
导入语句是`import`，完整的一条语法是：`import  java.util.Scanner;`，如果没有这条语句，初学者会在这里遇到困惑，并感到沮丧。

### 1.7.2 格式化输出
由于这部分内容很少使用，这里建议初学者自己阅读核心技术的有关章节，不再作通俗性解释。

### 1.7.3 文件输入与输出
文件是长久保留下来的由用户输入的某些有意义的内容。因此对于文件的输入与输出，和控制台输入输出，基本上没有差别。在Java中，要找到磁盘上的某个文件，你需要知道文件的地址，就像你要去朋友家必须要知道他家的地址一样，有了文件地址，通过`File`类的有参构造方法`new`出来一个`File`对象，那么你就可以找到这个文件，并在获取到读取权限的前提下，进入文件内部获取文件内容。具体的文件输入输出细节，这里不再转述，书上的例子很完美。

### 本节总结
输入输出的概念有点绕，事实上它们是相对立的伴生概念。首先有一条水流，当你需要 **喝水** 的时候，你就将水输入到嘴里；当你需要 **撒尿** 的时候，你就将水输出到便池。输入就是“喝水”，就是将流“读取”；输出就是“撒尿”，就是将流“写入”。很多时候，程序员为了形象地比喻一个概念，会在起名的过程中，遭遇非常之多的苦恼。一个好的名字，能帮助开发者获得无与伦比的体验。就拿一个著名的第三方框架`Okio`来说，开发它的程序员并没有针对读写的操作，建立类似`流`的概念。而是把输送方作为`源`，也就是`source`，把接收方作为`池`，也就是`sink`。源是用来读取的，池是用来写入的。建立这样简单的概念，甚至简单的接口后，你会发现，输入输出其实就应该这么简单易懂。


## 1.8 控制流程
程序是算法加数据的组合，因此，对于数据的操作属于一部分流程，而对于流程的控制，属于一部分逻辑。使用流程控制语句，将逻辑分为不同的部分，就有了程序的初级状态。这里我们只讨论流程控制部分，也就是针对算法逻辑的语法。

### 1.8.1 语句块及其作用域
块是一小部分区域，是一个圈子，用它来把某些逻辑保护起来，变成便捷的方法。语句块使用一对花括号`{}`来表示开始和结束，其作用域是中间部分的所有逻辑，除了外部传入的参数所指向的实例外，任何在语句块中声明的变量——`局部变量`，只要进入结束阶段，就会被`内存回收`掉。但是由于Java的`传参`实际上是传递`拷贝值`，因此局部变量的回收，不会导致真正意义上的内存数据丢失。这个概念可能会显得很饶，你可以将`拷贝值`理解为`配钥匙`，你从朋友那边配的钥匙是自己保管的，朋友的钥匙丢了，并不会导致房子也丢了，你可以用你配的钥匙重新打开房门。当然，这样的比喻显得有点低级，但比较适合初学者理解这种复杂的概念。

### 1.8.2 条件语句
这个语句在生活中很常见，某些人的口头禅是这样的：如果我怎样怎样，或我不怎样怎样，就会得到什么，或失去什么。在Java中，条件语句就这样理解，没毛病。先来看一个例子：
```
if (2+1==3) {
  System.out.println("我得到了什么？");
}
```
这是最简单也最常用的条件语句形式，表明的是，如果判断的表达式成立`true`，那么执行花括号内的语句（逻辑）。相对复杂的情况是，如果条件成立，进入逻辑真语句块；如果条件不成立，继续往下执行，或者进入逻辑假语句块。想要进入逻辑假语句块，首先要根据`if`建立同样的关键字，那就是`else`，代表含义——否则：
```
if (true) {
  System.out.println("我是逻辑真语句块");
} else {
  System.out.println("我是逻辑假语句快");
}
```
条件语句可以反复嵌套，关于嵌套的例子不再详述，请参见核心技术书上有关内容。

### 1.8.3 循环与确定循环、多重选择
- **while：**循环是在一个条件成立的情况下，反复进行逻辑真语句块的执行，直到条件不成立。从这个角度看，实际上能想象出来，程序员在遇到需要反复执行的条件语句时，感受到了这个世界的恶意（代码抄写一百遍是多少痛苦的事情），于是定义出不需要复制粘贴代码，就可以让代码逻辑反复执行下去的关键字——`while`。这样就保证了以后遇到循环的部分，都使用`while`就足够让人清楚这里发生了什么糟糕的事情。
- **for：**当程序员得知需要抄写一百遍代码时，内心的恐慌导致程序员开发出一种叫做`for`的确定循环关键字出来，这样就不需要在`while`外面去定义一个外部变量`int i = 0;`，而是内部就可以定义。然后再用条件判断`i<100;`来控制循环的次数，用`i++`来对变量进行自增，使得每次循环都有一个序号。`for`循环的三个部分其实很简单，而语句块中的逻辑可以直接从`while`中搬过来。
- **switch：**有时候`if`、`else`也会让人感受到恶意，为了保持可扩展性，每个`if`和每个`else`后面都有一大堆代表语句块的花括号`{}`，而一旦嵌套多起来，可阅读性就差了很多，这个时候，程序员为了方便理解，发明出一种叫做多重选择的关键字`switch`，然后只需要进行一次值保持`switch(表达式的值)`，然后将判断分发到各个`case:`，就足够完成多重选择。当然，为了避免重复选择，需要使用`break`语句打断下一次选择，毕竟乱花渐欲迷人眼。

### 1.8.4 中断控制流程语句
- **break：**首先介绍`跳出`，是因为前面出现了这个语句，而`跳出`经常用来逃离循环的魔掌。
- **continue：**有时候，并不是因为厌烦了某种重复，而是对后面发生的事情，感到恐惧，但又不想就此脱离，于是打算把后面的事情遗忘，重新开始判断。
- **return：**怨恨堆积到一种程度，难免遇到歇斯底里的时候，于是大家都想着放下一切，抱着当下的结果好聚好散。

### 本节总结
流程控制是考验程序员基本逻辑的扎实程度，通常是来源于生活以及对数学的感悟，如果思维比较直来直往，可能对逻辑有更好帮助。当然也不是说情商高则逻辑差，而是直男确实比较喜欢讲理，喜欢说实话，喜欢有板有眼，而不是钻空子，投机取巧，或者其他终南捷径。写程序没有捷径可走，都是实打实的逻辑布局。


## 1.9 大数值
这部分内容是选修，对于开发者而言，需要的时候再学习也不迟。

## 1.10 数组
数组的概念从书本中，能得到更好的升华，这里只强调一点：基础概念要熟练掌握，有自己的理解，光靠别人传授，并不能得到其中的奥义。

### 1.10.1 for each循环
这个循环结构是针对`for`循环的精简版，事实上内部还是在用`for`循环，只不过它把细节自动处理了。开发者只需要关心，数组的类型是什么，提取出来后，要用这个类型的对象去做什么。至于数组的大小和下标值的初始化，精简版会帮开发者完成。

### 1.10.2 数组初始化以及匿名数组
数组是一种对象，那么它的初始化也脱离不了对象的初始化。只不过有时候程序为了方便开发，总是做一些偷懒而增加概念复杂度的事情（这句话变复杂就是最好的例子）。数组初始化有了简化的书写形式，其实它和String对象可以直接用`""`包括起来，赋值给声明的String变量一样。至于匿名数组，它是有存在的意义——给原来的变量重新复制。所以，如果创建出来的东西不使用，跟占着茅坑不拉屎有什么区别？

这里纠正书里面的内容：
> 使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组。

这句话事实上是指，在不声明新变量的情况，利用旧的变量，来接收一个匿名数组的内存地址值。不要误解为，匿名数组不会创建“变量”（对象）。

### 1.10.3 数组拷贝
数组是对象，所以持有对象地址值的对应类型变量，事实上是将地址值拷贝给另外一个数组变量。

### 1.10.4 命令行参数
这部分内容可以跳过。

### 1.10.5 数组排序
排序的概念事实上要到后面才能理解，这里拿出来纯粹是一种炫耀，咱们知道它在炫耀就行，不用钻研太深。

### 1.10.6 多维数组
这种东西在数学中都属于比较烦人的内容，更别说在程序里了。所以，即便核心技术书中出现了这个内容，咱也不屑（不懂）解释。

### 本节总结
后面的内容都有凑字数的嫌疑……什么？你说是我在凑字数？我明明是跟核心技术这本书的作者学的。